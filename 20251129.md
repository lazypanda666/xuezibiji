

# c语言.C文件的处理

<img src="./img/20251129-1.png">

### 1.预处理（预编译）

(1)把include包含的头文件插入到.C文件中，并以.i文件格式保存；

(2)去点注释。

.i文件：预处理器执行宏替条件、条件编译以及包含指定的文件。

### 2.编译阶段

把.i文件转换为汇编语言，并以.s格式储存。

.s文件：汇编文件，由.i文件经过机器翻译产出。

### 3.汇编阶段

把.s文件转换为.o文件（二进制文件，不可直接执行）。

### 4.链接阶段

把二进制文件转换为可执行文件（如.exe文件）。

(.out)文件：二进制可执行目标文件，由机器码文件进一步简介生成。

各种符号引用和符号定义转换成为可执行文件中的合适信息（通常是虚拟地址）。

### *库函数

(1)静态库（*.a）

在编译链接时，把库文件的代码全部加入到可执行文件中，生成的文件比较大，但在运行时就不再需要库文件。

(2)动态库（*.so）

在编译链接时，并没有把库文件的代码加入到可执行文件中，而是在程序执行时由动态链接文件加载库。

# Linux命令

## 文件和目录操作

| 命令    | 全拼                    | 说明                           |
| ------- | ----------------------- | ------------------------------ |
| ls      | list                    | 列出目录内容                   |
| cd      | change directory        | 切换目录                       |
| pwd     | print working directory | 显示当前工作目录               |
| mkdir   | make directory          | 创建目录                       |
| rmdir   | remove directory        | 删除空目录                     |
| rm      | remove                  | 删除文件或目录                 |
| cp      | copy                    | 复制文件或目录                 |
| mv      | move                    | 移动或重命名文件或目录         |
| ln      | link                    | 创建链接                       |
| find    | find                    | 查找文件或目录                 |
| locate  | locate                  | 快速定位文件                   |
| which   | which                   | 查找命令的位置                 |
| whereis | where is                | 查找二进制文件、源代码和手册页 |
| du      | disk usage              | 显示目录空间使用情况           |
| df      | disk free               | 显示磁盘空间使用情况           |

## 文件内容操作

| 命令 | 全拼                            | 说明                         |
| ---- | ------------------------------- | ---------------------------- |
| cat  | concatenate                     | 显示文件内容                 |
| more | more                            | 分页显示文件内容             |
| less | less                            | 分页显示文件内容（功能更强） |
| head | head                            | 显示文件开头部分             |
| tail | tail                            | 显示文件结尾部分             |
| grep | global regular expression print | 文本搜索工具                 |
| sed  | stream editor                   | 流编辑器                     |
| awk  | Aho,Weinberger,Kernighan        | 文本处理工具                 |
| sort | sort                            | 排序文本行                   |
| uniq | unique                          | 去除重复行                   |
| wc   | work count                      | 统计字数、行数、字符数       |
| cut  | cut                             | 提取文本列                   |
| tr   | translate                       | 字符转换                     |
| diff | difference                      | 比较文件差异                 |

## 文件权限和属性

| 命令  | 全拼                         | 说明             |
| ----- | ---------------------------- | ---------------- |
| chmod | change mode                  | 修改文件权限     |
| chown | change owner                 | 修改文件所有者   |
| chgrp | change group                 | 修改文件所属组   |
| umask | user file-creation mode mask | 设置默认权限掩码 |
| stat  | status                       | 显示文件详细信息 |
| file  | file                         | 确定文件类型     |

## 进程管理

| 命令    | 全拼               | 说明             |
| ------- | ------------------ | ---------------- |
| ps      | process status     | 显示进程状态     |
| top     | table of processes | 实时显示进程信息 |
| htop    | htop               | 交互式进程查看器 |
| kill    | kill               | 终止进程         |
| killall | kill all           | 按名称终止进程   |
| jobs    | jobs               | 显示作业状态     |
| bg      | background         | 将作业放入后台   |
| fg      | foreground         | 将作业放在前台   |
| nohup   | no hang up         | 不挂断地运行命令 |

## ls

### 1.ls：列出当前目录下的所有文件

### 2.ls -a:显示隐藏文件

### 3.ls -l//ll:列出所有文件的属性

### 4.ls -la:列出全部文件的属性

## chmod  （权限）

d or -  //文件类型   rwx  // 文件所有者权限  r-x // 用户组权限  r-x // 其他用户权限 3  yushiqi  //属主名称   staff  //属组名称  224  //字节大小  10 27 12:03 //修改时间  week05

//d表示目录；r表示读（4//100）；w表示写（2//010）；x表示执行（1//001）；

语法：

```c
chmod  [选项]  权限模式  文件 ...
```

权限模式

1.符号模式（ugoa+/-权限）

[ugoa...] [[+-=] [rwxX]...] [,...]

| who  | 用户类型 | 说明                |
| ---- | -------- | ------------------- |
| u    | user     | 文件所有者          |
| g    | group    | 文件所有者所在组    |
| o    | others   | 所有其他用户        |
| a    | all      | 所有用户，相当于ugo |

| Operator | 说明                                                   |
| -------- | ------------------------------------------------------ |
| +        | 为指定的用户类型增加权限                               |
| -        | 去除指定用户类型的权限                                 |
| =        | 设置指定用户权限的设置，即将用户类型的所有权限重新设置 |

| 模式 | 名字       | 说明                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| r    | 读         | 设置为可读权限                                               |
| w    | 写         | 设置为可写权限                                               |
| x    | 执行       | 设置为可执行权限                                             |
| X    | 特殊执行   | 只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行 |
| s    | setuid/gid | 当文件被执行时，根据who参数指定的用户类型设置文件的setuid/gid权限 |
| t    | 粘贴位     | 设置为粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位 |

## cd

### 1.cd

进入后面输入的目录     eg:  cd  examples  //进入examples的目录

### 2.cd ..

回到上一层目录

### 3.cd .

进入当前目录

### 4.cd ../../（cd ..)

回到上上级目录

### 5.cd ~

切换到用户主目录（home)

### 6.cd -

切换到上次访问的目录

### 7.cd $VAR_NAME

切换到环境变量指定的目录

# 冒泡排序

## 1.算法步骤

#### （1）比较相邻元素

从列表的第一个元素开始，比较相邻的两个元素

#### （2）交换位置

如果前一个元素比后一个元素大（小），则交换它们的位置

#### （3）重复遍历

对列表中的每一个相邻元素重复上述步骤，直到列表的末尾

#### （4）缩小范围

忽略已经排序好的元素，重复上述步骤，直到整个列表排序完成

## 2.优缺点

#### （1）优点

- 实现简单，代码易于理解

- 原地排序，不需要额外的储存空间

#### （2）缺点

- 效率低下，尤其是对于大规模数据集

- 不适合处理几乎已经有序的列表，因为仍然需要进行多次遍历

```c
#include <stdio.h>
void bubble_sort (int arr[], int len)
{
    for (int i = 0; i < len-1 ;i++)
    {
        for (int j = 0; j < len-i-1; j++)
        {
            if (arr[j] > arr[j+1])
            {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```



# 选择排序

### 1.算法步骤

#### （1）初始化

将列表分为已排序部分和未排序部分。初始时，已排序部分为空，未排序部分为整个列表

#### （2）查找最小值

在未排序部分中查找最小的元素

#### （3）交换位置

将找到的最小元素与未排序部分的第一个元素交换位置

#### （4）更新范围

将未排序部分的起始位置向后移动一位，扩大已排序部分的范围

#### （5）重复步骤

重复上述步骤，直到未排序部分为空，列表完全有序

### 2.优缺点

#### （1）优点

- 实现简单，代码易于理解
- 原地排序，不需要额外的储存空间
- 对于小规模数据集，性能尚可接受

#### （2）缺点

- 时间复杂度高，不适合大规模数据集
- 不稳定排序算法（如果存在相同元素，可能会改变它们的相对顺序

```c
#include <stdio.h>
void selection_sort (int arr[],int len)
{
    for (int i = 0; i < len-1; i++)
    {
        int min=i;
        for (int j = i+1; j < len; j++)
        {
            if (arr[j] < arr[min])
                min = j;
        }
        int temp = arr[i];
        arr[i] = arr[min];
        arr[min] = temp;
    }
}
```

